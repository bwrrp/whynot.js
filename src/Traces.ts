import FromBuffer from './FromBuffer';
import ProgramInfo from './ProgramInfo';
import Trace from './Trace';

const EMPTY_SET: Set<Trace> = new Set();

export default class Traces {
	// Incoming steps (origin pc) by pc
	private _fromByPc: FromBuffer;
	private _fromBySurvivorPc: FromBuffer;
	private _survivors: Set<number> = new Set();

	// Records generated by pc in the current generation
	private _recordByPc: any[] = [];

	// Traces for anything that survived until now, updated when the current generation ends.
	// These swap each generation in order to minimize allocations.
	private _traceBySurvivorPc: (Trace | null)[] = [];
	private _nextTraceBySurvivorPc: (Trace | null)[] = [];

	constructor(programInfo: ProgramInfo) {
		this._fromByPc = new FromBuffer(programInfo.maxFromByPc);
		this._fromBySurvivorPc = new FromBuffer(programInfo.maxSurvivorFromByPc);
		for (let i = 0; i < programInfo.programLength; ++i) {
			this._recordByPc.push(null);
			this._traceBySurvivorPc.push(null);
			this._nextTraceBySurvivorPc.push(null);
		}

		this._traceBySurvivorPc[0] = Trace.EMPTY;
	}

	public reset(clearSurvivors: boolean): void {
		this._fromByPc.clear();
		this._fromBySurvivorPc.clear();
		this._survivors.clear();

		this._recordByPc.fill(null);

		if (clearSurvivors) {
			this._traceBySurvivorPc.fill(null);
			this._nextTraceBySurvivorPc.fill(null);
			this._traceBySurvivorPc[0] = Trace.EMPTY;
		}
	}

	public record(pc: number, record: any): void {
		this._recordByPc[pc] = record;
	}

	public has(pc: number): boolean {
		return this._fromByPc.has(pc) || this._traceBySurvivorPc[pc] !== null;
	}

	public add(fromPc: number, toPc: number): void {
		this._fromByPc.add(fromPc, toPc);
	}

	public hasSurvivor(pc: number): boolean {
		return this._survivors.has(pc);
	}

	public addSurvivor(fromPc: number, toPc: number): void {
		this._fromBySurvivorPc.add(fromPc, toPc);
		this._survivors.add(toPc);
	}

	public buildSurvivorTraces(): void {
		const previousTraceBySurvivorPc = this._traceBySurvivorPc;
		const prefixesByPc = new Map<number, { isDone: boolean; prefixes: Set<Trace> }>();
		const fromByPc = this._fromByPc;
		const recordByPc = this._recordByPc;
		function trace(pc: number): Set<Trace> {
			const existingPrefixes = prefixesByPc.get(pc);
			if (existingPrefixes !== undefined) {
				if (!existingPrefixes.isDone) {
					// Trace is a cycle, ignore this path
					return EMPTY_SET;
				}
				return existingPrefixes.prefixes;
			}

			// Create new cache entry, marked as not done to detect cycles
			const prefixes = new Set();
			prefixesByPc.set(pc, { isDone: false, prefixes });

			const startingTrace = previousTraceBySurvivorPc[pc];
			if (startingTrace !== null) {
				prefixes.add(startingTrace);
			} else if (!fromByPc.has(pc)) {
				throw new Error(`Trace without source at pc ${pc}`);
			}
			fromByPc.forEach(pc, fromPc => {
				trace(fromPc).forEach(prefix => prefixes.add(prefix));
			});

			if (prefixes.size > 0) {
				// Valid prefixes found, check for records
				const record = recordByPc[pc];
				if (record !== null) {
					const prefixesArray = Array.from(prefixes);
					prefixes.clear();
					prefixes.add(
						// TODO: merge record arrays over non-forking / non-joining edges
						new Trace(
							prefixesArray.length === 1 && prefixesArray[0] === Trace.EMPTY
								? []
								: prefixesArray,
							[record]
						)
					);
				}
			}

			// Mark cached entry as complete
			prefixesByPc.get(pc)!.isDone = true;
			return prefixes;
		}

		function createTrace(prefixes: Trace[]) {
			return prefixes.length === 1 ? prefixes[0] : new Trace(prefixes, null);
		}

		this._traceBySurvivorPc = this._nextTraceBySurvivorPc;
		this._nextTraceBySurvivorPc = previousTraceBySurvivorPc;
		for (let pc = 0, programLength = this._traceBySurvivorPc.length; pc < programLength; ++pc) {
			if (!this._survivors.has(pc)) {
				this._traceBySurvivorPc[pc] = null;
				continue;
			}

			const prefixes: Set<Trace> = new Set();
			this._fromBySurvivorPc.forEach(pc, fromPc => {
				trace(fromPc).forEach(trace => prefixes.add(trace));
			});
			this._traceBySurvivorPc[pc] = createTrace(Array.from(prefixes));
		}
	}

	public getTraces(acceptedPcs: number[]): Trace[] {
		return acceptedPcs.map(pc => this._traceBySurvivorPc[pc]!);
	}
}
