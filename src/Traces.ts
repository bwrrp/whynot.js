import FromBuffer from './FromBuffer';
import ProgramInfo from './ProgramInfo';
import Trace from './Trace';

const EMPTY_SET: Set<Trace> = new Set();

export default class Traces {
	// Incoming steps (origin pc) by pc
	private _fromByPc: FromBuffer;
	private _fromBySurvivorPc: FromBuffer;
	private _survivors: Set<number> = new Set();

	// Records generated by pc in the current generation
	private _recordByPc: any[] = [];

	// Traces for anything that survived until now, updated when the current generation ends
	private _traceBySurvivorPc: Map<number, Trace> = new Map();

	constructor(programInfo: ProgramInfo) {
		this._fromByPc = new FromBuffer(programInfo.maxFromByPc);
		this._fromBySurvivorPc = new FromBuffer(programInfo.maxSurvivorFromByPc);
		for (let i = 0; i < programInfo.programLength; ++i) {
			this._recordByPc.push(null);
		}

		this._traceBySurvivorPc.set(0, Trace.EMPTY);
	}

	public reset(clearSurvivors: boolean): void {
		this._fromByPc.clear();
		this._fromBySurvivorPc.clear();
		this._survivors.clear();

		this._recordByPc.fill(null);

		if (clearSurvivors) {
			this._traceBySurvivorPc.clear();
			this._traceBySurvivorPc.set(0, Trace.EMPTY);
		}
	}

	public record(pc: number, record: any): void {
		this._recordByPc[pc] = record;
	}

	public has(pc: number): boolean {
		return this._fromByPc.has(pc) || this._traceBySurvivorPc.has(pc);
	}

	public add(fromPc: number, toPc: number): void {
		this._fromByPc.push(fromPc, toPc);
	}

	public hasSurvivor(pc: number): boolean {
		return this._survivors.has(pc);
	}

	public addSurvivor(fromPc: number, toPc: number): void {
		this._fromBySurvivorPc.push(fromPc, toPc);
		this._survivors.add(toPc);
	}

	public buildSurvivorTraces(): void {
		const previousTraceBySurvivorPc = this._traceBySurvivorPc;
		const prefixesByPc = new Map<number, { isDone: boolean; prefixes: Set<Trace> }>();
		const fromByPc = this._fromByPc;
		const recordByPc = this._recordByPc;
		function trace(pc: number): Set<Trace> {
			const existingPrefixes = prefixesByPc.get(pc);
			if (existingPrefixes !== undefined) {
				if (!existingPrefixes.isDone) {
					// Trace is a cycle, ignore this path
					return EMPTY_SET;
				}
				return existingPrefixes.prefixes;
			}

			// Create new cache entry, marked as not done to detect cycles
			const prefixes = new Set();
			prefixesByPc.set(pc, { isDone: false, prefixes });

			const startingTrace = previousTraceBySurvivorPc.get(pc);
			if (startingTrace !== undefined) {
				prefixes.add(startingTrace);
			} else if (!fromByPc.has(pc)) {
				throw new Error(`Trace without source at pc ${pc}`);
			}
			fromByPc.forEach(pc, fromPc => {
				trace(fromPc).forEach(prefix => prefixes.add(prefix));
			});

			if (prefixes.size > 0) {
				// Valid prefixes found, check for records
				const record = recordByPc[pc];
				if (record !== null) {
					const prefixesArray = Array.from(prefixes);
					prefixes.clear();
					prefixes.add(
						// TODO: merge record arrays over non-forking / non-joining edges
						new Trace(
							prefixesArray.length === 1 && prefixesArray[0] === Trace.EMPTY
								? []
								: prefixesArray,
							[record]
						)
					);
				}
			}

			// Mark cached entry as complete
			prefixesByPc.get(pc)!.isDone = true;
			return prefixes;
		}

		function createTrace(prefixes: Trace[]) {
			return prefixes.length === 1 ? prefixes[0] : new Trace(prefixes, null);
		}

		this._traceBySurvivorPc = new Map();
		this._survivors.forEach(pc => {
			const prefixes: Set<Trace> = new Set();
			this._fromBySurvivorPc.forEach(pc, fromPc => {
				trace(fromPc).forEach(trace => prefixes.add(trace));
			});
			this._traceBySurvivorPc.set(pc, createTrace(Array.from(prefixes)));
		});
	}

	public getTraces(acceptedPcs: number[]): Trace[] {
		return acceptedPcs.map(pc => this._traceBySurvivorPc.get(pc)!);
	}
}
